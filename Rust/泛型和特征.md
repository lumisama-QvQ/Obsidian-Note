## 泛型是什么
通俗的讲，就是一种给程序员们偷懒的方式，用一个函数来处理不同的数据
```rust
fn add<T>(a: T, b: T) -> T {
	a + b
}
```
这里的`T`便是**泛型参数**，出于惯例我们习惯用`T`[^1]作为首选，实际在Rust中用什么都可以，用它来代指一些的类型

## 泛型的基本使用
1. 泛型在使用前**必须声明**：
```rust
fn add<T>(a: T, b: T) -> T 
```
`add<T>`先对泛型`T`声明，之后在函数参数中使用泛型`T`，这里可解释为有函数`add`它有泛型`T`，它有俩参数`a`，`b`为`T`类型， 这个函数的返回值也为`T`
2. **一种泛型只能有一种类型**，比如例子中的`x`, `y`必须是同一种类型
### 显式的指定泛型的类型参数
比如我们最开始写的`add`函数，如果我们这么写：
```rust
println!("add i8: {}", add(2i8, 3i8));
println!("add i32: {}", add(2i32, 3i32));
println!("add f64: {}", add(1.23, 1.32));
```

它会报错：
```
error[E0369]: cannot add `T` to `T` // 无法将 `T` 类型跟 `T` 类型进行相加
 --> src/main.rs:2:7
  |
2 |     a + b
  |     - ^ - T
  |     |
  |     T
  |
help: consider restricting type parameter `T`
  |
1 | fn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {
  |         +++++++++++++++++++++++++++
```

因为浮点型没有实现可比较特征`std::cmp::PartialOrd`
此时只需要对`T`进行限制即可
```rust
fn add<T: std::ops::Add<optput = T>>(a:T, b:T) -> T
```

对于泛型限制，多个限制之间用`+`隔开
```rust
fn add<T: std::ops::Add<optput = T> + Display>(a:T, b:T) -> T
```
但当特征限制过多时， 这样会使函数签名很长，此时我们可以使用`where`关键词
```
fn add<t>(a: T, b: T) -> T
	where T: std::ops::Add<optput = T> + Display {}
```

## 在方法中使用泛型

这里主要提一下方法的，结构体，枚举的泛型使用都和函数类似
```rust
struct Point<T> {
	x: T,
	y: T
}
impl<T> Point<T> {
	fn x(&self) -> &T {
	&self.x
	}
}
```
同样是**提前声明**，有些人（比如我）在初次看到`impl<T> Point<T>`会有些迷惑，这里`<T>`为什么出现了俩次？事实上这里的`Point<T>`不再是泛型声明，而是整体作为一个结构体类型，因为我们定义的结构体就是`Point<T>`而不是`Point`
### 为具体的泛型类型实现方法
在上文中的`Point`结构体中



[^1]: Type
