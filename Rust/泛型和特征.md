## 泛型是什么
通俗的讲，就是一种给程序员们偷懒的方式，用一个函数来处理不同的数据
```rust
fn add<T>(a: T, b: T) -> T {
	a + b
}
```
这里的`T`便是**泛型参数**，出于惯例我们习惯用`T`[^1]作为首选，实际在Rust中用什么都可以，用它来代指一些的类型

## 泛型的基本使用
泛型在使用前**必须声明**：
```rust
fn add<T>(a: T, b: T) -> T 
```
`add<T>`先对泛型`T`声明，之后在函数参数中使用泛型`T`，这里可解释为有函数`add`它有泛型`T`，它有俩参数`a`，`b`为`T`类型， 这个函数的返回值也为`T`

### 显式的指定泛型的类型参数
比如我们最开始写的`add`函数，如果我们这么写：
```rust
println!("add i8: {}", add(2i8, 3i8));
println!("add i32: {}", add(2i32, 3i32));
println!("add f64: {}", add(1.23, 1.32));
```

它会报错：
```
error[E0369]: cannot add `T` to `T` // 无法将 `T` 类型跟 `T` 类型进行相加
 --> src/main.rs:2:7
  |
2 |     a + b
  |     - ^ - T
  |     |
  |     T
  |
help: consider restricting type parameter `T`
  |
1 | fn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {
  |         +++++++++++++++++++++++++++
```

因为浮点型没有实现可比较特征`std::cmp::PartialOrd`
此时只需要对`T`进行限制即可
```rust
fn add<T: std::ops::Add<optput = T>>(a:T, b:T) -> T
```

对于泛型限制，多个限制之间用`+`隔开
```rust
fn add<T: std::ops::Add<optput = T> + Display>(a:T, b:T) -> T
```
但当特征限制过多时， 这样会使函数签名很长，此时我们可以使用`where`关键词
```
fn add<t>(a: T, b: T) -> T
	where T: std::ops::Add<optput = T> + Display {}
```

## 在结构体中使用泛型
先看例子：
```rust
struct Point<T> {
	x: T,
	y: T,
}
```
这里有俩点**注意**
1. 提前声明，同泛型函数一样，使用前要声明
2. 

[^1]: Type
