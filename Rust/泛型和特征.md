## 泛型是什么
通俗的讲，就是一种给程序员们偷懒的方式，用一个函数来处理不同的数据
```rust
fn add<T>(a: T, b: T) -> T {
	a + b
}
```
这里的`T`便是**泛型参数**，出于惯例我们习惯用`T`[^1]作为首选，实际在Rust中用什么都可以，用它来代指一些的类型

## 泛型的基本使用
1. 泛型在使用前**必须声明**：
```rust
fn add<T>(a: T, b: T) -> T 
```
`add<T>`先对泛型`T`声明，之后在函数参数中使用泛型`T`，这里可解释为有函数`add`它有泛型`T`，它有俩参数`a`，`b`为`T`类型， 这个函数的返回值也为`T`
2. **一种泛型只能有一种类型**，比如例子中的`x`, `y`必须是同一种类型
### 显式的指定泛型的类型参数
比如我们最开始写的`add`函数，如果我们这么写：
```rust
println!("add i8: {}", add(2i8, 3i8));
println!("add i32: {}", add(2i32, 3i32));
println!("add f64: {}", add(1.23, 1.32));
```

它会报错：
```
error[E0369]: cannot add `T` to `T` // 无法将 `T` 类型跟 `T` 类型进行相加
 --> src/main.rs:2:7
  |
2 |     a + b
  |     - ^ - T
  |     |
  |     T
  |
help: consider restricting type parameter `T`
  |
1 | fn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {
  |         +++++++++++++++++++++++++++
```

因为浮点型没有实现可比较特征`std::cmp::PartialOrd`
此时只需要对`T`进行限制即可
```rust
fn add<T: std::ops::Add<optput = T>>(a:T, b:T) -> T
```

对于泛型限制，多个限制之间用`+`隔开
```rust
fn add<T: std::ops::Add<optput = T> + Display>(a:T, b:T) -> T
```
但当特征限制过多时， 这样会使函数签名很长，此时我们可以使用`where`关键词
```
fn add<t>(a: T, b: T) -> T
	where T: std::ops::Add<optput = T> + Display {}
```

## 在方法中使用泛型

这里主要提一下方法的，结构体，枚举的泛型使用都和函数类似
```rust
struct Point<T> {
	x: T,
	y: T
}
impl<T> Point<T> {
	fn x(&self) -> &T {
	&self.x
	}
}
```
同样是**提前声明**，有些人（比如我）在初次看到`impl<T> Point<T>`会有些迷惑，这里`<T>`为什么出现了俩次？事实上这里的`Point<T>`不再是泛型声明，而是整体作为一个结构体类型，因为我们定义的结构体就是`Point<T>`而不是`Point`
### 为具体的泛型类型实现方法
在上文中的`Point`结构体中，如果我们想给某个指定类型实现方法，就可以这么写：
```rust
impl Point<f32> {
	fn add(&self) -> Point {}
}
```

这样我们就为`Point<f32>`类型新写了一个方法，该方法只有在`T`为`f32`类型时才有，而其他的`T`就没有定义这个方法

## const 泛型
一种**针对值**的泛型，用于解决数组长度问题
这是由于在`rust`中不同长度的数组不是同一种类型，比如`[1, 2, 3]`和`[1, 2]`就不是一种类型，这会使处理数组的函数难以编写
这里写一个用于输出数组的函数：
```rust
fn display_array<T: std::fmt::Debug>(arr: &[T]) {
	println!("{:?}", arr);
}
```
此处我们使用引用作为函数的参数，因为在`rust`语言中函数是必须显式的指出类型的，而所有的数组的引用都可以用`&[T]`来表示。
这似乎是解决了问题，但若要实现的函数的参数不是引用呢？
正因为所有的数组的引用都可以为`&[T]`，对于一个存储着`T`类型的数组，从`&[T]`上我们是无法知道它的长度的
这里我们写一个数组相加的函数：
```rust
fn add<T： optput=>(a: &[T], b: &[T]){}
```
我们传入`[1, 2, 3]`,`[1, 2]`这显然满足参数的定义，但这俩明显无法进行相加

[^1]: Type
